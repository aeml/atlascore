name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-test:
    name: Build & Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake lcov

      - name: Install Dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew update
          brew install cmake lcov

      - name: Configure (Linux with coverage)
        if: runner.os == 'Linux'
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DATLASCORE_ENABLE_COVERAGE=ON -DATLASCORE_BUILD_TESTS=ON

      - name: Configure (Windows / macOS)
        if: runner.os != 'Linux'
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DATLASCORE_BUILD_TESTS=ON

      - name: Build
        run: cmake --build build --config Debug --parallel

      - name: Run Tests
        run: |
          cd build
          ctest -C Debug --output-on-failure

      - name: Collect Coverage (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          cd build
          lcov --directory . --capture --output-file coverage.base.info
          # Remove system and test files
          lcov --remove coverage.base.info '/usr/*' '*/tests/*' --output-file coverage.info
          lcov --list coverage.info

      - name: Enforce Coverage Threshold (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          cd build
          # Use lcov summary for reliable parsing.
          echo "---- lcov summary ----"
          lcov --summary coverage.info || true
          LINE_COV=$(lcov --summary coverage.info | awk '/lines/ {print $2}' | sed 's/%//')
          THRESHOLD=65
          if [ -z "$LINE_COV" ]; then
            echo "Failed to parse line coverage percentage."; exit 1; fi
          echo "Line coverage parsed: ${LINE_COV}% (threshold ${THRESHOLD}%)"
          awk -v cov="$LINE_COV" -v thr="$THRESHOLD" 'BEGIN { if (cov+0 < thr+0) { exit 1 } }'
        shell: bash

      - name: Generate HTML Report (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          cd build
          genhtml coverage.info --output-directory coverage-report

      - name: Upload Coverage Artifact (Ubuntu)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: build/coverage-report

      - name: Upload Raw Coverage Data (Ubuntu)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-info
          path: build/coverage.info

      - name: Upload Test Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs-${{ matrix.os }}
          path: build/Testing

  sanitize-linux:
    name: Sanitizers (ubuntu-latest)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      - name: Configure (ASan + UBSan)
        run: |
          cmake -S . -B build-sanitize \
            -DCMAKE_BUILD_TYPE=Debug \
            -DATLASCORE_BUILD_TESTS=ON \
            -DCMAKE_CXX_FLAGS="-fsanitize=address,undefined -fno-omit-frame-pointer" \
            -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=address,undefined" \
            -DCMAKE_SHARED_LINKER_FLAGS="-fsanitize=address,undefined"

      - name: Build
        run: cmake --build build-sanitize --config Debug --parallel

      - name: Run Tests
        run: |
          cd build-sanitize
          ctest -C Debug --output-on-failure

      - name: Upload Sanitizer Test Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs-sanitizers-linux
          path: build-sanitize/Testing

